{"version":3,"file":"cevitxe.cjs.production.js","sources":["../src/actions.ts","../src/constants.ts","../src/dynamicMiddleware.ts","../src/mockCrypto.ts","../src/save.ts","../src/feed.ts","../src/adaptReducer.ts","../src/initialize.ts","../src/load.ts","../src/middleware.ts"],"sourcesContent":["import { Change } from './types'\r\nimport { APPLY_CHANGE } from './constants'\r\n\r\nexport const actions = {\r\n  applyChange: (change: Change) => ({\r\n    type: APPLY_CHANGE,\r\n    payload: { change },\r\n  }),\r\n}\r\n","export const APPLY_CHANGE = 'cevitxe/APPLY_CHANGE';\r\n","import { compose, Middleware } from 'redux'\r\n\r\nconst createDynamicMiddlewares = () => {\r\n  let allDynamicMiddlewares: Middleware[] = []\r\n\r\n  const enhancer: Middleware = store => next => action => {\r\n    const chain = allDynamicMiddlewares.map(middleware => middleware(store))\r\n    return compose<Middleware>(...chain)(next)(action)\r\n  }\r\n\r\n  const addMiddleware = (...middlewares: Middleware[]) => {\r\n    allDynamicMiddlewares = [...allDynamicMiddlewares, ...middlewares]\r\n  }\r\n\r\n  const removeMiddleware = (middleware: Middleware) => {\r\n    const index = allDynamicMiddlewares.findIndex(d => d === middleware)\r\n\r\n    if (index === -1) {\r\n      console.error('Middleware does not exist!', middleware)\r\n      return\r\n    }\r\n\r\n    allDynamicMiddlewares = allDynamicMiddlewares.filter(\r\n      (_, mdwIndex) => mdwIndex !== index\r\n    )\r\n  }\r\n\r\n  const resetMiddlewares = () => {\r\n    allDynamicMiddlewares = []\r\n  }\r\n\r\n  return {\r\n    enhancer,\r\n    addMiddleware,\r\n    removeMiddleware,\r\n    resetMiddlewares,\r\n  }\r\n}\r\n\r\nconst dynamicMiddlewaresInstance = createDynamicMiddlewares()\r\n\r\nexport const cevitxeMiddleware = dynamicMiddlewaresInstance.enhancer\r\n\r\nexport const {\r\n  addMiddleware,\r\n  removeMiddleware,\r\n  resetMiddlewares,\r\n} = dynamicMiddlewaresInstance\r\n\r\nexport { createDynamicMiddlewares }\r\n","import crypto from 'hypercore-crypto';\r\n// TODO: Get crypto working properly\r\n// This is a hack because I was getting errors verifying the remove signature\r\n// I took the code from hypercore and am just always returning true for the verification\r\n// We need to look deeper into why it's not signing properly or maybe just provide our\r\n// own crypto methods here.\r\nexport const mockCrypto = {\r\n  sign: (data: any, sk: any, cb: any) => {\r\n    return cb(null, crypto.sign(data, sk));\r\n  },\r\n  verify: (_sig: any, _data: any, _pk: any, cb: any) => {\r\n    // Always say it's a valid signature (for testing)\r\n    return cb(null, true);\r\n  },\r\n};\r\n","import automerge from 'automerge'\r\n\r\nexport const save = <T>(key: string, state: T): void => {\r\n  const history = automerge.save(state)\r\n  localStorage.setItem(key, history)\r\n}\r\n","import automerge from 'automerge'\r\nimport { Buffer } from 'buffer'\r\nimport hypercore from 'hypercore'\r\nimport crypto from 'hypercore-crypto'\r\nimport pump from 'pump'\r\nimport rai from 'random-access-idb'\r\nimport { Middleware, Store } from 'redux'\r\nimport signalhub from 'signalhub'\r\nimport swarm from 'webrtc-swarm'\r\n\r\nimport { actions } from './actions'\r\nimport { addMiddleware } from './dynamicMiddleware'\r\nimport { mockCrypto } from './mockCrypto'\r\n\r\n// This is currently a class but might make more sense as just a function\r\nclass CevitxeFeed {\r\n  private reduxStore: Store\r\n  private feed: Feed<any>\r\n  private databaseName: string\r\n  private key: Key\r\n  private secretKey: Key\r\n  private peerHubs: Array<string>\r\n\r\n  constructor(reduxStore: any, options: any) {\r\n    if (!options.key)\r\n      throw new Error('Key is required, should be XXXX in length')\r\n    // hypercore seems to be happy when I turn the key into a discoveryKey,\r\n    // maybe we could get away with just using a Buffer (or just calling discoveryKey with a string?)\r\n    this.key = crypto.discoveryKey(Buffer.from(options.key))\r\n    if (!options.secretKey)\r\n      throw new Error('Secret key is required, should be XXXX in length')\r\n\r\n    // hypercore doesn't seem to like the secret key being a discoveryKey,\r\n    // but rather just a Buffer\r\n    this.secretKey = Buffer.from(options.secretKey)\r\n    this.databaseName = options.databaseName || 'data'\r\n    this.peerHubs = options.peerHubs || [\r\n      'https://signalhub-jccqtwhdwc.now.sh/', // default public signaling server\r\n    ]\r\n    this.reduxStore = reduxStore\r\n\r\n    // Init an indexedDB\r\n    // I'm constructing a name here using the key because re-using the same name\r\n    // with different keys throws an error \"Another hypercore is stored here\"\r\n    const todos = rai(`${this.databaseName}-${this.getKeyHex().substr(0, 12)}`)\r\n    const storage = (filename: any) => todos(filename)\r\n\r\n    // Create a new hypercore feed\r\n    this.feed = hypercore(storage, this.key, {\r\n      secretKey: this.secretKey,\r\n      valueEncoding: 'utf-8',\r\n      crypto: mockCrypto,\r\n    })\r\n    this.feed.on('error', (err: any) => console.log(err))\r\n\r\n    this.feed.on('ready', () => {\r\n      console.log('ready', this.key.toString('hex'))\r\n      console.log('discovery', this.feed.discoveryKey.toString('hex'))\r\n      this.joinSwarm()\r\n    })\r\n\r\n    this.startStreamReader()\r\n\r\n    // Inject our custom middleware using redux-dynamic-middlewares\r\n    // I did this because we need a middleware that can use our feed instance\r\n    // An alternative might be to instantiate Feed and then create the redux store,\r\n    // then you'd just need a Feed.assignStore(store) method or something to give this\r\n    // class a way to dispatch to the store.\r\n    addMiddleware(this.feedMiddleware)\r\n  }\r\n\r\n  // This middleware has an extra function at the beginning that takes\r\n  // a 'store' param, which we're not using so it's omitted.\r\n  // This is an implementation detail with redux-dynamic-middlewares\r\n  feedMiddleware: Middleware = store => next => action => {\r\n    // this.feed.append(JSON.stringify(action.payload.action))\r\n    const prevState = store.getState()\r\n    const result = next(action)\r\n    const nextState = store.getState()\r\n    const changes = automerge.getChanges(prevState, nextState)\r\n    changes.forEach(c => this.feed.append(JSON.stringify(c)))\r\n    return result\r\n  }\r\n\r\n  // Read items from this and peer feeds,\r\n  // then dispatch them to our redux store\r\n  startStreamReader = () => {\r\n    // Wire up reading from the feed\r\n    const stream = this.feed.createReadStream({ live: true })\r\n    stream.on('data', (value: string) => {\r\n      try {\r\n        const change = JSON.parse(value)\r\n        console.log('onData', change)\r\n        this.reduxStore.dispatch(actions.applyChange(change))\r\n      } catch (err) {\r\n        console.log('feed read error', err)\r\n        console.log('feed stream returned an unknown value', value)\r\n      }\r\n    })\r\n  }\r\n\r\n  // Join our feed to the swarm and accept peers\r\n  joinSwarm = () => {\r\n    // could add option to disallow peer connectivity here\r\n    const hub = signalhub(this.getKeyHex(), this.peerHubs)\r\n    const sw = swarm(hub)\r\n    sw.on('peer', this.onPeerConnect)\r\n  }\r\n\r\n  // When a feed peer connects, replicate our feed to them\r\n  onPeerConnect = (peer: any, id: any) => {\r\n    console.log('peer', id, peer)\r\n    pump(\r\n      peer,\r\n      this.feed.replicate({\r\n        encrypt: false,\r\n        live: true,\r\n        upload: true,\r\n        download: true,\r\n      }),\r\n      peer\r\n    ) \r\n  }\r\n\r\n  getKeyHex = () => this.key.toString('hex')\r\n}\r\n\r\nexport { CevitxeFeed as Feed }\r\n","import { ReducerAdapter } from './types'\r\nimport automerge from 'automerge'\r\nimport { APPLY_CHANGE } from './constants'\r\n\r\nexport const adaptReducer: ReducerAdapter = proxyReducer => (\r\n  state,\r\n  { type, payload }\r\n) => {\r\n  switch (type) {\r\n    case APPLY_CHANGE: {\r\n      console.log('APPLY_CHANGE REDUCER!!')\r\n      return automerge.applyChanges(state, [payload.change])\r\n    }\r\n    default: {\r\n      const msg = `${type}: ${JSON.stringify(payload)}`\r\n      const fn = proxyReducer({ type, payload })\r\n      return fn && state\r\n        ? automerge.change(state, msg, fn) // return a modified Automerge object\r\n        : state // no matching change function was found, return state unchanged\r\n    }\r\n  }\r\n}\r\n","import automerge from 'automerge'\r\n\r\n// Builds a new automerge object from the object provided\r\nexport const initialize = <T>(obj: T) =>\r\n  automerge.change(automerge.init<T>(), 'initialize', (d: T) => {\r\n    for (const k in obj) {\r\n      d[k] = obj[k]\r\n    }\r\n  })\r\n","import automerge from 'automerge'\r\n\r\nexport const load = <T>(key: string): T | null => {\r\n  const history = localStorage.getItem(key)\r\n  return history ? automerge.load(history) : null\r\n}\r\n","import { Middleware } from 'redux'\r\nimport { save } from './save'\r\n\r\ntype Options = {\r\n  key: string\r\n}\r\n\r\nexport const middleware = ({ key }: Options): Middleware => {\r\n  return store => next => action => {\r\n    const result = next(action)\r\n    const nextState = store.getState()\r\n    save(key, nextState)\r\n    return result\r\n  }\r\n}\r\n"],"names":["actions","applyChange","change","type","payload","createDynamicMiddlewares","allDynamicMiddlewares","enhancer","store","next","action","chain","map","middleware","compose","addMiddleware","middlewares","removeMiddleware","index","findIndex","d","filter","_","mdwIndex","console","error","resetMiddlewares","dynamicMiddlewaresInstance","cevitxeMiddleware","mockCrypto","sign","data","sk","cb","crypto","verify","_sig","_data","_pk","save","key","state","history","automerge","localStorage","setItem","reduxStore","options","prevState","getState","result","nextState","getChanges","forEach","c","_this","feed","append","JSON","stringify","createReadStream","live","on","value","parse","log","dispatch","err","hub","signalhub","getKeyHex","peerHubs","swarm","onPeerConnect","peer","id","pump","replicate","encrypt","upload","download","toString","Error","discoveryKey","Buffer","from","secretKey","databaseName","todos","rai","this","substr","hypercore","filename","valueEncoding","joinSwarm","startStreamReader","feedMiddleware","proxyReducer","applyChanges","msg","fn","obj","init","k","getItem","load"],"mappings":"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"}